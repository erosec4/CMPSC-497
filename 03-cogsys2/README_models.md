# Pizza Builder with DM
In `pizza_dm.py`, the constructor for the `PizzaBuilder_DM` class includes statements which add chunks to declarative memory. These chunks dictate the chronology of the steps required to make both types of pizza. The last line of the constructor sets the goal to `start_pizza`, causing the `prep_ingredients` rule to fire. This rule changes the goal to `build_pizza` with slots for  `done` and `new`, which are intentionally different from the slots used in DM chunks/requests, `prev` and `next`. The same functionality could be accomplished without the additional goal slots, but for the sake of learning, I included those as well. When the goal is set to `build_pizza`, the `add_toppings` rule fires. This rule requests the next step from the declarative memory in line 49, using the current `next` value as the new `prev` value and searching for the new `next` value. The goal is modified in this same manner to continue the pattern of updating both the goal and the memory.

This `add_topping` rule fires until the value in the `next` slot is "onion" (determined by the retrieval condition `next:?next_ingred!onion`). The `add_onion` rule will fire instead, which adds onion as the last topping to the pizza (as it is the last topping for both types of pizza) and sets the goal to `cook_pizza`, allowing the memory request loop to end as the final rule, `cook_pizza_step` fires.

# Vacuum Agent with DM
To start `vacuumAgent_dm.py`, the functions that implement the swirl pattern and wall tracing in my `vacuumAgent.py` file were transferred to this new file. To add the declarative memory feature, I first created line 30--a request to retrieve a location of a dirty square from the agent's declarative memory with y location value of 5--in the constructor of the `VacuumAgent` class. The logic behind this choice is that an error will be produced when there are no chunks in the DM, allowing a differentiation between the initial run and the second run after the map is reset and memory has been added. A condition of `error:True` (meaning DM is empty/it's the initial run) for `DM_module` fires a new rule called `begin_swirl` that starts the swirl pattern by setting the goal as the original goal from the previous assignment. The agent follows the pattern until the dirty spots are all clean. Before a square is cleaned, the `clean_cell` rule adds the x and y locations of the square to memory (using `body.[x,y]` property of the agent). Once all squares are clear, the map resets.

Since these new rules need a goal and memory retrieval to fire, the constructor of the `VacuumAgent` class has to fire again after the map is reset. This did not happen in the given code. The original agent would stop and no rules would fire since the goal could not be modified nor memory retrieved post-reset. To fix this, it was necessary to add lines 108 and 109 and to edit line 110 to create a second agent (another object of the `VacuumAgent` class), copy the DM from the original agent `agent` to the new agent `agent2`, and add `agent2` to the map instead. With these changes, the constructor can fire, allowing the goal to be set (line 28) and the first chunk of memory to be retrieved (line 30), causing `recall_dirty_spots_dm` to fire. The new agent is exactly the same as the original, since line 109 copies the declarative memory chunks directly from the original into the new: `agent2.DM_module.dm = agent.DM_module.dm`. For the final piece of functionality, the agent does not clean the same spot twice as the condition `require_new=True` was added to the memory request in line 38. Furthermore, the print statement from line 56 shows each chunk in the declarative memory every time a new chunk is added, confirming that the chunks are properly added and stored in the DM and no shortcuts (loops, conditionals, falsifying memory, etc.) were taken in the reinstantiation of the agent.